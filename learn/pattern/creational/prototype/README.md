# Prototype Pattern (原型模式)

## 定义
原型模式是一种创建型设计模式,通过复制现有对象(原型)来创建新对象,而不是通过实例化类。这种模式在创建成本较高时特别有用。

## 目的
- 避免重复的初始化代码
- 通过克隆来创建对象,而不是使用构造函数
- 当创建对象的成本较高时,提高性能
- 隐藏对象创建的复杂性

## 使用场景
- 对象的创建成本较高(需要大量计算或访问外部资源)
- 需要创建大量相似对象
- 需要保护对象的创建过程
- 需要独立于产品的创建方式

**实际应用示例:**
- 文档编辑器中的复制/粘贴功能
- 游戏中的对象克隆(敌人、道具等)
- 配置对象的复制
- 数据库连接池中的连接对象

## 优点
1. **性能提升** - 克隆比重新创建快
2. **简化创建** - 避免复杂的初始化逻辑
3. **运行时添加和删除产品** - 动态配置
4. **减少子类** - 不需要为每种配置创建新类

## 缺点
1. **深拷贝复杂** - 包含引用类型时需要实现深拷贝
2. **循环引用** - 对象间有循环引用时克隆困难
3. **克隆方法实现** - 每个类都需要实现克隆方法

## Go 特有实现

### 方法1: 定义 Clone 接口
```go
type Cloneable interface {
    Clone() Cloneable
}
```

### 方法2: 使用序列化/反序列化
```go
import (
    "bytes"
    "encoding/gob"
)

func DeepCopy(src, dst interface{}) error {
    var buf bytes.Buffer
    if err := gob.NewEncoder(&buf).Encode(src); err != nil {
        return err
    }
    return gob.NewDecoder(&buf).Decode(dst)
}
```

### 方法3: 手动实现拷贝方法
最直接和可控的方式,推荐使用。

## 示例代码说明

本示例实现了一个简历克隆系统:
1. 定义 `Prototype` 接口,包含 `Clone()` 方法
2. 实现 `Resume` 结构体,包含基本信息和工作经历
3. 实现深拷贝逻辑,确保引用类型被正确复制
4. 演示如何通过克隆创建新对象并修改

## 相关模式

- **Abstract Factory**: 原型模式可以与抽象工厂模式结合使用
- **Composite**: 通常与组合模式一起使用,克隆复杂的树形结构
- **Decorator**: 装饰器模式的对象也可以被克隆

## 与其他模式的区别

- **vs Factory Method**: 工厂方法通过继承创建对象,原型通过克隆创建对象
- **vs Builder**: Builder 关注分步骤构建,Prototype 关注克隆现有对象
- **vs Singleton**: Singleton 确保只有一个实例,Prototype 创建多个副本

## 注意事项

1. **深拷贝 vs 浅拷贝**: 根据需求选择合适的拷贝方式
2. **线程安全**: 在并发环境中克隆时需要考虑线程安全
3. **性能考虑**: 克隆大对象时注意性能影响
4. **引用类型处理**: Go 中的 slice、map、channel 等需要特殊处理
